# 大恒相机

## 1.接口

### 1.1 API

为用户提供了用户控制相机的通用编程接口 ==GxIAPI== 和图像处理算法接口==DxImageProc==。

### 1.2 GenTL

基于 Gen\<i>Cam （标准中通用传输层的标准输出接口）提供的GenTL。

### 1.3 GigE Vision

遵循 GigE Vision.



## 2.LED灯状态

![LED](/home/peter/图片/LED灯状态.png)

## 3. IO 接口

![IO接口](/home/peter/图片/IO口.png)

###3.1 输入引脚

输入信号，分别是 Line0、Line2、Line3。其中 Line0 为单向光耦输入 IO，Line2、Line3 为可配置方向的 IO。

注意：触发滤波，触发延迟，设置输入反引脚。

### 3.2 输出引脚

输出信号，分别是 Line1、Line2、Line3。。其中 Line1 为单向光耦输出 IO，Line2、Line3 为可配置方向的 IO。

注意：用户状态，这支输出引脚反向。

 

## 4.图像采集控制

###4.1 开始采集

#### 4.1.1 连续采集

连续模式下，相机接收到开采命令后，根据曝光时间和相关参数的设置，以一定帧率进行采集和传输。

连续采集配置：MER-G-P/MER-G 相机支持连续采集功能。在应用程序中，如果用户想要使用连续采集功能，只需要在“采集控制”选项中，==“触发模式”选择“off”==即可。MER-G-P/MER-G 相机的==默认工作方式为连续采集==。

连续模式下采集图像时，根据参数设置默认值输出图像。

设置 ROI 尺寸，包间隔，也有可能会影响连续采集的的帧率。

####4.1.2 触发采集

触发模式下，相机接收到开采命令后，每接收到一个有效的触发信号（包括软触发或者外触发）
，根据曝光时间和相关参数的设置，产生一触发帧。

### 4.2 停止采集

#### 4.2.1 传输过程中停采

传输完当前包后立刻终止采集，当前传输帧为非完整帧，不会给用户。

#### 4.2.2 传输等待时停采

立即停止

注：由于设备限制，在设置完开采或者停采后，需要等待一段时间，该时间至少要大于当前曝光时间和帧周期之和。

###4.3 采集模式切换
不需要停采操作可直接切换。相互切换时，都要等到当前模式采集的数据传输完全才会切换。



## 5. 触发

### 5.1 软触发

在应用程序中，如果用户想要使用软触发采集功能，需要在“采集控制”选项中， “触发模式”选择“On”， “触发源”选择“Software”，每对“软触发”按的“TriggerSoftware”，每对“软触发”按钮的“TriggerSoftware”点击一次，将产生一帧软触发图像。所有的软触发命令，都是主机通过 Gigabit Ethernet 总线发送命令触发相机采集和传输图像。

相机切换到软触发模式后，相机会等待用户发送软触发命令，然后==软触发命令来后开始采集图像==。一般来说，相机输出的帧率会和软触发==频率==。用户使用软触发功能时，相关特性如下：

1)软触发的触发频率小于当前配置下的最大帧率时，帧率将和软触发帧率一致；如果软触发的频率大于最大帧率时，会有软触发信号被屏蔽，帧率将小于软触发帧率；

2)==触发延迟==，即对接收的软触发信号，进行延迟处理后触发产生图像帧，默认配置为不进行触发延迟操作。

### 5.2 外触发（硬触发）

在应用程序中，如果用户想要使用外触发采集功能，需要在“采集控制”选项中，“触发模式”选择“On”，“触发源”选择-==“Line0”，“Line2”，“Line3”中的一个==。同时根据触发源的选择项，在相机的航插接口中，完成好外触发的物理连接。

MER-G-P/MER-G 相机对外触发输入信号处理，支持的特性包括：

1）==触发极性==，是否对输入外触发信号进行极性翻转操作。默认配置为不翻转；

2）==触发滤波功能==，是否对输入外触发信号进行滤波操作，MER-G-P/MER-G 相机支持分别对上升沿和下降沿进行滤波设置。默认配置为不滤波操作。==触发滤波有触发延迟作用==；

3）==触发延迟==，相机对接收的外触发信号，是否进行延迟处理后触发产生图像帧，默认配置为不进行触发延迟操作。

注意：**Line0 内部使用光耦隔离电路，对信号有一定的延迟作用**，且上升沿的延迟要稍小于下降沿的延迟。上升沿延时约几个到十几个 us，下降沿延时十几个到几十个 us，所以一个正脉冲触发信号经过Line0 后，到达相机内部实际被加宽了（约 20-40us）；反之一个负脉冲触发信号经过 Line0 后，到达相机内部实际被变窄了（约 20-40us）。如果此时使用了滤波，且对滤波系数要求严格，可以根据有效触发脉冲的高低适当微调滤波参数，对滤波参数要求不严格的用户可以忽略这一差异。



##6 曝光

### 6.1 曝光延迟

由外触发到 sensor 真正开始曝光之间，有一小段延时，总称为曝光延时，共包含四部分时间：

T1：外部信号经过光耦或 GPIO 时，==硬件电路引入的延时==。值一般在几 us 到几十 us，延时主要受连接方式、驱动强度和温度影响，外部环境不变时，该延时一般稳定；

T2：==触发滤波引入的延时==，比如设置触发滤波时间为 50us，则 T2 对应 50us；

T3：==触发延迟==（trigger_delay），相机还支持触发延迟功能，如果触发延迟设置 200us，则 T3 为 200us；

T4： ==sensor 时序延时==， sensor 内部真正开始曝光是与行时序对齐，所以 T4 最大有一个行周期的抖动，
每款 sensor 该数值不一样，某些延时较大的产品（几百 us 以上）还有额外的配置时间也计入 T4 中了。

### 6.2 设置曝光

####6.2.1 全局曝光模式

Sensor 的==所有行同时开始曝光==，并同时结束曝光，在曝光结束后，Sensor 将所有电子从感光区转到存储区，之后逐行的读出像素数据。

好处是获得图像每一行的曝光时间比较一致，并且在拍摄运动物体时图像不会出现偏移和歪斜。

#### 6.2.2 逐行曝光模式

逐行曝光从第一行开始曝光，一个行周期之后第二行才开始曝光，依次类推。

技术难度较全局曝光 sensor 低，价格便宜，且分辨率较大，对于一些静态图像拍摄是不错的选择。

### 方法6.3 设置曝光时间

曝光时间可设，步长 1us，各款相机曝光范围见下表。

使用行曝光 sensor 的相机，曝光精度受 sensor 限制，用户接口和 demo 步长显示为 1us，实际是 1个行周期。当输入值曝光值不能被行周期整除时，上取整处理，比如最大窗口时行周期为 36us，设置 80us曝光时间，实际曝光时间为 108us。

当外部光源为日光或直流光源时，相机对曝光无特殊要求；当使用交流光源时，为滤除交流光源闪烁影响，==建议曝光时间为光源周期的整数倍==，如 100Hz 的光源，曝光时间最好设置为 10ms 的整数倍（我们通常使用的日光灯的频率为 50Hz）。

### 6.4 （非）交叠曝光

####6.4.1 非交叠曝光

==帧周期 >= 曝光时间 + 读出时间==

在一帧图像完全结束曝光和读取之后才开始进行下一张图像的曝光。

#### 6.4.2 交叠曝光

==帧周期 < 曝光时间 + 读出时间==

在前一张图像曝光完，进行读取的时候，就开始下一张图像的曝光。

交叠曝光能获得更高帧率。



## 7. 基本属性

### 7.1  增益

增大增益能使得图像亮度提高，每提高6dB，图像灰度值将增加近一倍。另一种提高图像亮度的方法为通过修改查找表改变相机的数字增益。这两种方式都将放大图像噪声。

###7.2 像素格式

通过设置像素格式，可以==选择相机输出图像数据的格式==。无论是彩色或者黑白相机，可供选择的像素格式与相机的具体型号相关。

#### 7.2.1 Mono8格式

像素格式设置为 Mono8 的时候，相机输出图像中每个像素的亮度值为 8bits 数据。

#### 7.2.2 Mono12,Mono10格式

当像素格式设置为 Mono12 或 Mono10 的时候，相机输出图像中每个像素的亮度值为 16bits 数据，Mono12 格式有效数据为 12bits，高 4bits 补 0；Mono10 式有效数据为 10bits，高 6bits 补 0。

#### 7.2.3 BayerRG8 格式

当像素格式设置为 BayerRG8 的时候，相机输出图像中每个像素的亮度值为 8bits 数据，根据像素点所在位置的差异，分别亮度值表示红、绿、蓝三个分量。

注：还有 BayerRG12、BayerRG10 ，BayerGR8 格式等



## 8. 自动处理

### 8.1 自动曝光，自动增益 ，自动白平衡ROI 设置

自动曝光自动增益**采用感兴趣区域（ROI）中的图像数据计算相机参数，从而对相机的曝光时间和增益值进行调节。**

ROI 通过如下方式定义：
           AAROIOffsetX： X 轴方向偏移；
           AAROIOffsetY： Y 轴方向偏移；
           AAROIWidth： ROI 区域的宽；
           AAROIHeight： ROI 区域的高；

Offset 是相对于图像左上角为原点的偏移值。其中，X 轴方向偏移和宽度的步长为 4，Y 轴方向偏移和高度的步长为 2。其中， AAROIWidth 可设置的最小值为 ==16==，最大值为当前图像宽；AAROIHeight 可设置的最小值为 16，最大值为当前图像高

### 8.2 自动增益

自动增益自动调节相机的增益值，==使 AAROI 中的平均灰度达到期望灰度值==。自动增益可采用“once”和
“continuous”模式进行控制。
当采用“once”模式时，将 ROI 中数据调节至期望灰度值，然后关闭自动增益功能；当采用“continuous”时，相机一直根据 ROI 中数据自动调节相机增益值，使 ROI 中数据保持在期望灰度附近。
==期望灰度值由用户设置，其值与数据位宽有关==，对于 8 位像素数据，期望灰度的范围是 0~255；对于10 位像素数据，期望灰度的范围是 0 ~ 1023；对于 12 位像素数据，期望灰度的范围是 0 ~ 4095。
==相机在设置的最小增益和最大增益范围内调节增益值。==
==自动增益可以和自动曝光同时使用，此时，调节采用曝光优先==，即：曝光达到设置的最大值后，才调节增益值。

### 8.3 自动曝光

自动曝光自动调节相机的曝光值，==使 AAROI 中的平均灰度达到期望灰度值==。自动曝光可采用“once”和
“continuous”模式进行控制。
当采用“once”模式时，将 ROI 中数据调节至期望灰度值，然后关闭自动曝光功能；当采用“continuous”时，相机一直根据 ROI 中数据自动调节相机的曝光时间，使 ROI 中数据保持在期望灰度附近；

==期望灰度值由用户设置，其值与数据位宽有关==，对于 8 位像素数据，期望灰度的范围是 0~255，对于12 位像素数据，期望灰度的范围是 0 ~ 4095。
==相机在设置的最小曝光和最大曝光范围内调节曝光值。==
==自动曝光可以和自动增益同时使用，此时，调节采用曝光优先==，即：曝光达到设置的最大值后，才调节增益值。

### 8.4 增益和曝光的区别

都可以提高亮度，但一般优先曝光，因为曝光时间增长可以提高信噪比（降低噪声比例），而增益使用很少，曝光难以获得光线，或者需要减少曝光时间的时候，才会选择提高增益，因为使用增益提高亮度会引入大量噪声。

### 8.5 自动白平衡

自动白平衡根据 ROI 中的数据计算白平衡系数，然后==根据系数对图像的各分量进行调节，使 ROI 区域中的红，绿、蓝三分量的值一致。==自动白平衡只对彩色传感器有效。
自动白平衡可以采用“once”和“continuous”模式进行控制。当采用“once”模式时，相机只调节一次，采用“continuous”模式时，相机不断根据 ROI 中的数据调节白平衡系数。

自动白平衡还可以选择==色温==，当选择的色温为“Adaptive”时，ROI 中的数据总是调节为红、绿、蓝三分量一致；当选择具体色温时，相机根据光源对系数进行修正，使 ROI 区域的色调与光源的色调一致，即：高色温偏冷，低色温偏暖。

### 8.6 查找表

Sensor 读出的模拟信号经 ADC 转换后，原始数据位深常大于 8bits，有 14bits、12bits、10bits 等。当选择输出的数据位深为 8 位时，需要将 12 位数据转换成 8 位数据。查找表实现这种 12 位到 8 位的映射。
查找表可以是线性查找表，也可以是非线性查找表。

### 8.7 测试图

#### 8.7.1 灰度渐变侧视图

灰度渐变测试图中，帧内==所有像素的灰度值都相等==。相邻帧中，相邻帧的后一帧比上一帧的灰度值递增 1，递增到 255 后，下一帧灰度值回到 0，依次循环。

####8.7.2 竖条纹滚动测试图

竖条纹滚动测试图中，图像内==每一列中像素的灰度值都相等==，每一行中从左到右每个像素递增 1，到255 后，下一像素灰度值回到 0。

####8.7.3 斜条纹滚动测试图

斜条纹滚动测试图中，每帧图像内，相邻行的第一个像素值依次递增 1，直到最后一行。像素灰度值递增到 255 后，下一灰度值回到 0。相邻列的第一个像素值依次递增 1，直到最后一列。像素灰度值递增到255 后，下一灰度值回到 0。

### 8.8  参数组

通过设置相机的各种参数，可以使相机在不同的环境中能够发挥最佳的性能。设定参数的方法有两种：一种是==手动修改==各项参数，另一种是通过==加载参数组==的方式。为了能够保存用户使用的特定参数环境，避免每次打开相机时都要重新设置参数，MER-G-P/MER-G 相机提供了==参数组保存功能==，可以轻松实现对整套参数进行保存，包括控制相机所需的参数。==配置参数分为三种类型：当前生效的配置参数、厂商默认配置参数（Default）、用户配置参数（UserSet）。==
对配置参数可以进行三种操作，包括==保存参数、加载参数、设置启动参数组。==保存参数是指保存生效的配置参数到设定的用户配置参数组中。加载参数是指将厂商默认配置参数或用户配置参数加载到当前生效的配置参数中。选择启动参数组是指用户可以指定一组参数，在相机复位或重新上电后，这组参数会自动加载到生效的配置参数中，相机会在这组参数下进行工作。这组参数可以是厂商默认配置参数，也可以是用户配置参数。

#### 8.8.1 配置参数的类型

配置参数的类型包括：生效的配置参数、厂商默认配置参数、用户配置参数。
生效的配置参数：生效的配置参数是指相机当前所用的控制参数。使用 API 函数或 Demo 程序修改当前相机的控制参数就是在修改生效的配置参数，生效的配置参数存放在相机的易失性存储器中，==所以在相机复位或重新上电后，生效的配置参数会丢失。==
厂商默认配置参数（Default）：在相机出厂前，相机的生产厂商会对相机进行测试以评估相机的性能并优化相机的配置参数。厂商默认配置参数就是生产厂商在特定环境下优化后的相机配置参数，厂商默认配置参数存放在相机的非易失性存储器中，故在相机复位和重新上电后，厂商默认配置参数是不会丢失的，并且==厂商默认配置参数是不可修改的。==
用户配置参数（UserSet）：生效的配置参数存放在相机的易失性存储器中，在相机复位和重新上电后会丢失。可以将生效的配置参数保存到用户配置参数，用户配置参数位于相机的非易失性存储器中。在相机复位和重新上电后，用户配置参数不会丢失。MER-G-P/MER-G 系列相机可以保存一组用户配置参数。

#### 8.8.2 配置参数的操作

对配置参数的操作包括以下三种：保存参数、加载参数、设置启动参数组。

==保存参数==：存储当前生效的配置参数到用户配置参数组中。存储的步骤如下：

1. 修改相机的配置参数，直到相机的运行到达用户的需求

2. 执行保存参数命令，将生效的配置参数保存到用户参数组中。
  用户参数组中保存的相机配置参数包括：
  ⚫ 增益
  ⚫ 曝光时间
  ⚫ 传输控制模式
  ⚫ 像素格式
  1418.功能定义
  ⚫ 水平偏移、垂直偏移、图像宽度、图像高度
  ⚫ 流通道包长、包间隔
  ⚫ 事件使能
  ⚫ 触发模式、触发源、触发极性、触发延迟
  ⚫ 上升沿触发滤波、下降源触发滤波
  ⚫ IO 引脚方向、引脚电平反转、引脚输出源、用户自定义输出
  ⚫ 帧覆盖使能
  ⚫ 帧信息使能
  ⚫ 测试图选择
  ⚫ 期望灰度值
  ⚫ 自动曝光使能、自动曝光最大值、最小值
  ⚫ 自动增益使能、自动增益最大值、最小值
  ⚫ 自动调节感兴趣区域 x 坐标、y 坐标、宽度、高度
  ⚫ 自动白平衡、自动白平衡光源
  ⚫ 自动白平衡感兴趣区域 x 坐标、y 坐标、宽度、高度
  ⚫ 白平衡系数 R、G、B 分量
  ⚫ LUT 查找表

  ==加载参数==：将厂商默认配置参数或用户配置参数加载到生效的配置参数中。执行这一操作后，生效的配置参数将被用户选择加载的参数覆盖，形成新生效的配置参数。执行这一操作的步骤如下：

  1) 选择加载参数功能项。
  2) 选中希望加载的参数组，完成加载参数。

​        ==改变启动参数组==：用户能够选择厂商默认配置参数或用户配置参数作为默认的启动参数组。在相机复
​        位和重新上电后，启动参数组中的参数将加载到生效的配置参数中。

###8.9  用户自定义名称

户可以给相机设置一个自己设计的唯一标识，并可以通过这个自定义的唯一标识来打开并控制相机。多个相机同时使用时，需保证每个相机的用户自定义名称的唯一性，否则造成打开相机时定位设备异常。



## 9. 图像传输

### 9.1 最大帧率

最大帧率受网络允许帧率，图像采集时间和相机曝光时间影响。相机的帧率取网络最大允许帧率、采集帧率、曝光帧率三者之中的最小值。

#### 9.1.1  网络允许最大帧率

网络允许最大帧率是==当前网络能够支持的相机传输最大帧率==。MER-G-P/MER-G 系列相机的网络接口支持最大帧率由相机分辨率、像素格式（图像位深）、有效网络带宽等决定。可以用公式表示：
                                   ==网络允许最大帧率 = 有效网络带宽/分辨率/图像位深==

####9.1.2 相机采集时间计算

相机采集时间和==ROI 设置中的垂直偏移、高度相关==。当 ROI 设置中垂直偏移和高度发生变化时，会影响相机前端采集的帧周期，进而影响采集帧率。

#### 9.1.3 相机帧率

相机的帧率除了受到网络最大允许带宽、相机采集时间的限制之外，曝光时间也会影响帧率。例如，对于 MER-200-20GM/C-P 相机，当曝光时间为 100ms 时，对应的帧率为 10 帧/秒。

### 9.2 包长

指==相机向主机端传输流通道数据的网络包大小==，以字节为单位，默认值为 1500。其中包括 IP 头，UDP 头和 GVSP 头的长度总计 36 字节，因此在默认情况下流通道网络包中的有效负载为 1464 字节。==推荐使用最大包长设置为 8192 字节，可以提高网络传输性能。==

### 9.3 包间隔

用于控制相机传输图像流数据的带宽。==包间隔是在流通道传输的相邻网络数据包之间插入的空闲时钟个数==。增加包间隔能够降低相机对网络带宽的占用率，同时也有可能降低了相机的帧率（相机帧率还取决于曝光时间、相机采集时间）。

传输单个流数据包所需时间：

T 𝑑𝑎𝑡𝑎 = (𝑆𝑖𝑧𝑒 𝑝𝑘𝑡 × 8𝑏𝑖𝑡𝑠) ⁄ 𝑆𝑝𝑒𝑒𝑑 𝑙𝑖𝑛𝑘

包延迟时间：

𝑇 𝑑𝑒𝑙𝑎𝑦 = 𝐷𝑒𝑙𝑎𝑦 𝑝𝑘𝑡 ⁄ 125,000,000

其中：包长𝑆𝑖𝑧𝑒 𝑝𝑘𝑡 、包间隔𝐷𝑒𝑙𝑎𝑦 𝑝𝑘𝑡 、预留带宽BandW 𝑟𝑒𝑠𝑒𝑟𝑣𝑒 、连接速度𝑆𝑝𝑒𝑒𝑑 𝑙𝑖𝑛𝑘

有效网络带宽：

Band𝑊 𝑎𝑣𝑖𝑎𝑙 = (𝑆𝑖𝑧𝑒 𝑝𝑘𝑡 × 8𝑏𝑖𝑡𝑠 × （1 − Band𝑊 𝑟𝑒𝑠𝑒𝑟𝑣𝑒 ）/(𝑇 𝑑𝑎𝑡𝑎 + 𝑇 𝑑𝑒𝑙𝑎𝑦 )

### 9.4预留带宽

预留带宽（Bandwidth Reserve）用于为数据包重传和相机与主机之间控制数据传输预留一部分带宽，也可以用于多机传输时，对于每个相机带宽的分配限制。例如，网络带宽值为 1Gbps，设置预留带宽值为20%，则带宽将被预留下 0.2Gbps。当预留的带宽大于传输所需的最大带宽时，相机将降低帧率来保证传输的稳定性。

### 9.5 帧传输延迟

多个相机和主机通过交换机连接时，如果同时触发这些相机采集图像，在传输图像由于交换机的瞬时带宽过大，存储能力有限，会==出现数据丢失问题==。因此需要使用帧传输延迟避免该问题发生。在触发模式下，通过设置传输控制模式为“用户控制”，当相机接到软触发命令或者外触发信号并完成图像采集以后，将图像保存在相机内部的帧存中，等待主机端发送“开始传输”命令以后，相机将采集到的图像传输到主机端。传输延迟时间由主机端决定。在多个相机同时触发的时候，可以为每台相机设置不同的传输延迟时间，以避免交换机的瞬时带宽过大。

注：帧传输延迟功能仅在触发模式下有效。



## 10.事件

特定的情形发生时，相机将产生对应的“事件”，并将事件消息发送到 PC 机，告知 PC 有“事件”发生了。在 MER-G-P/MER-G 系列相机中，==相机会在以下几种情况下产生并传递事件：曝光结束、图像帧数据丢弃、触发信号溢出、图像帧存数据不为空和事件队列溢出==。每种事件都有相应的使能位，==在默认情况下，相机的所有事件使能都为关闭状态==。

在使用事件功能的时候，需要首先使能相应的事件，并设置==事件通道的端口值，事件重传的超时时间和事件重传的次数==给相机。当事件的重传超时时间设置为 0 时，相机发送的事件将不需要 PC 返回应答包。当事件通道的端口值为 0 时，相机将不会发送事件给 PC。其他情况下，相机需要接收到 PC 的应答包后才会发送下一个事件。当相机发送的事件没有接收到应答包的时候，相机会根据设置的重传的超时时间和重传次数重传此事件。

![事件](/home/peter/图片/事件返回信息.png)

其中：时间戳为事件发生的时刻，从相机上电或复位后开始计时。时间戳的位宽是 64bits，单位为 20ns。

###10.1曝光结束事件

在曝光结束事件使能时，当相机的传感器完成曝光以后，相机向 PC 机发送一次曝光结束事件，表示==已经完成曝光==。

### 10.2 图像帧数据丢弃事件

当==相机向内部帧存写入数据的平均带宽大于读出数据的平均带宽时，会出现帧存满的情况。如果帧存满后继续写入图像数据，将覆盖以前帧存里的图像数据==。此时，相机向 PC 机发送一次图像帧数据丢弃事件，表示有一帧图像被丢弃覆盖。==这样在读出下一帧图像时，图像会有跳跃。==

###10.3 帧存不为空事件

当相机向内部帧存写入数据的平均带宽大于读出数据的平均带宽时，此时如果帧存未满，但帧存内有未发送完成的图像帧数据，在新的图像帧写入帧存之前，相机向 PC 机发送一个帧存不为空事件，==表示在写入新的图像帧时，前一帧图像还未发送完成==。

### 10.4 触发信号溢出事件

==当相机接收到外触发或者软触发信号时，如果前端传感器正处于曝光状态，将无法响应新的触发信号，相机机向 PC 机发送一个触发信号溢出事件。==注意，如果在一帧图像的采集周期内接收到多个触发信号，相机仅发送一次触发信号溢出事件。

### 10.5 事件队列溢出

在相机内部，有一个用于缓存事件的事件队列。正常情况下，发送给 PC 的事件数据包只包含一个事件。当有多个事件同时发生时，或者事件传输有延迟的时候，可以在相机内部使用事件队列对事件进行缓存。当可以发送事件的时候，相机会将队列里面缓存的所有事件都发送出，这时发送给 PC 的事件数据包会包含多个事件。但如果相机运行在高帧率模式下，发送的事件个数超过相机的缓存能力时，如果使能事件队列溢出事件，相机会向 PC 机发送一个事件队列溢出事件，并丢弃当前缓存的所有事件。



## 11.常见问题

### 11.1相机开始采集后没有图像

1) 确认相机包长设置大于 1500，若主机不是巨帧模式，修改主机为巨帧模式；
2) 加载默认参数组后，重新打开程序，再次开始采集，确认是否有图像；
3) 打开演示程序，打开属性配置页面，查看流配置信息，确认是否有接收到数据包，如果有数据包，但都为残帧，请按照2.2 节中使用环境注意事项进行确认。

### 11.2 多相机同时使用时丢帧严重

1. 采用调节包长或包间隔参数，此方式会严重降低帧率；
2. 采用多网卡，即相机分别连接到不同的网卡上，以分担网络占用带宽。

###11.3  设备开始采集失败，提示 Attach者触发方式采集的用户可以选择， 但对于采集帧率要求较高Buffer 失败
1) 方法 1： 修改流层的参数 MaxNumQueueBuffer（ 采集队列最大 Buffer 个数），为 9 以下；解决方案的缺点会降低采集性能，对于采集帧率要求较低或者触发方式采集的用户可以选择， 但对于采集帧率要求较高的用户不建议使用；
2) 方法 2： 增加物理内存大小，并将系统换成 64 位系统， 推荐使用 Win7 及以上系统，此方法能较好解决此问题。



## 12. 流程

###12.1  整体工作流程

![](/home/peter/图片/整体工作流程.png)

### 12.2 相机控制流程

![](/home/peter/图片/相机控制流程.png) 

### 12.3 DQAllBufs 采集流程

![](/home/peter/图片/DQAllBufs采集流程.png)

注意事项：

1. ==用户采集线程必须在开采后启动，在停采前销毁。==

2. GXStreamOff 停采接口或 GXQAllBufs 接口会将所有通过 GXDQAllBufs 获取到的图像 buf 放回 GxIAPI库，之后不能再访问这些图像 buf 指针；
3. 上述流程演示了启动线程的方式进行图像采集，也可以不启动线程直接在开采后调用 GXDQAllBufs 采集图像。
4. 图像处理或显示出现延迟的情况下，可采用此种采集方案只处理或显示数组中的最后一幅图像来缓解延迟。

### 12.4 回调采集流程

![](/home/peter/图片/回调采集流程.png)

### 12.5  掉线事件获取流程

![](/home/peter/图片/掉线事件获取流程.png)

### 12.6 远端设备事件获取流程

![](/home/peter/图片/远端设别事件获取流程.png)



## 13 . 编程指引

### 13.1 环境

GxIAPI 和 DxImageProc 是大恒图像软件部出品的通用 C++编程接口和图像处理算法接口，

➢ GxIAPI.dll、DxImageProc.dll         动态链接库文件
➢ GxIAPI.lib、DxImageProc.lib         编译程序时静态链接
➢ GxIAPI.h、DxImageProc.h             接口及宏声明头文件

用户使用 GxIAPI 或 DxImageProc 创建工程的时候需要包含.h 头文件和.lib 静态链接库，才能正常调用、编译。

### 13.2 初始化

在使用 GxIAPI 接口之前必须调用 ==GXInitLib 对库进行初始化操作==，当用户应用程序==退出的时候也必须调用 GXCloseLib 来释放资源==与 GxInitLib 相对应，本文所有的片段示例代码中默认都进行了初始化和反初始化 GxIAPI 库的操作。

```c++
#include"GxIAPI.h"
int main(int argc, char* argv[])
{
    GX_STATUS status = GX_STATUS_SUCCESS;
    //在 起 始 位 置 调 用 GXInitLib()进 行 初 始 化 ， 申 请 资 源
    status = GXInitLib();
    if (status != GX_STATUS_SUCCESS)
    {
     return 0;
    }
    //使 用 GxIAPI
    //...
    //在 结 束 的 时 候 调 用 GXCLoseLib()释 放 资 源
    status = GXCloseLib();
    return0;
}
```

### 13.3 枚举相机并获取信息

用户可以==调用 GXUpdateDeviceList 接口来枚举当前可用的设备，返回设备个数，==然后在==不打开相机的前提下使用 GxGetAllDeviceBaseInfo 来获取设备基础信息==。

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
uint32_t nDeviceNum = 0;
status = GXUpdateDeviceList(&nDeviceNum, 1000);
if (status == GX_STATUS_SUCCESS&&nDeviceNum> 0)
{
GX_DEVICE_BASE_INFO *pBaseinfo = new GX_DEVICE_BASE_INFO[nDeviceNum];
uint32_t nSize = nDeviceNum * sizeof(GX_DEVICE_BASE_INFO);  //nsize记录总相机信息大小
//获 取 所 有 设 备 的 基 础 信 息
status = GXGetAllDeviceBaseInfo(pBaseinfo, &nSize);
delete []pBaseinfo;
}
```

###13.4 配置相机 IP 地址

1) 对于 GigE 网络相机，用户可以==调用 GXGigEIpConfiguration 配置相机 IP 地址==，使用这种方式设置的 IP 地址在相机掉电重启后仍然有效。调用==此函数需要传入目的相机的 MAC 地址，可以通过调用GxGetDeviceIPInfo 获得==。

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//本 例 以 永 久 IP 配 置 方 式 说 明 ,其 他 IP 配 置 方 式 类 似
//设 置 为 永 久 IP 配 置 方 式
status = GXGigEIpConfiguration(szMAC, emIpConfigureMode, szIpAddress, szSubnetMask,
szDefaultGateway, szUserID);
```

2) 用户同样可以==调用 GXGigEForceIp 配置相机 IP 地址==，使用这种方式设置的 IP 地址只在本次使用中有效，相机掉电重启后会恢复以前的 IP 地址。调用此函数==需要传入目的相机的 MAC 地址，可以通过调用
GxGetDeviceIPInfo 获得==。

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
// ForceIp
status = GXGigEForceIp(szMAC, szIpAddress, szSubnetMask, szDefaultGateway);
```

### 13.5  打开关闭相机

调用 GXUpdateDeviceList 接口枚举设备后，返回的设备个数如果大于 0，说明当前有可用设备，用户==调用 GxOpenDevice 接口来打开设备==。

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
size_t nDeviceNum = 0;
GX_OPEN_PARAM stOpenParam;
status = GXUpdateDeviceList(&nDeviceNum, 1000);
if (status == GX_STATUS_SUCCESS&&nDeviceNum> 0)
{
GX_DEV_HANDLE hDevice = NULL;
//打 开 枚 举 列 表 中 的 第 一 台 设 备 。
//假设枚举到了 3 台可用设备，那么用户可设置 stOpenParam 参数的 pszContent 字段为 1、2、3
stOpenParam.accessMode = GX_ACCESS_EXCLUSIVE;
stOpenParam.openMode = GX_OPEN_INDEX;
stOpenParam.pszContent = "1";
//通 过 序 列 号 打 开 设 备
//stOpenParam.openMode = GX_OPEN_SN;
//stOpenParam.pszContent = "EA00010002";
//通 过 IP 地 址 打 开 设 备
//stOpenParam.openMode = GX_OPEN_IP;
//stOpenParam.pszContent = "192.168.40.35";
//通 过 MAC 地 址 打 开 设 备
//stOpenParam.openMode = GX_OPEN_MAC;
//stOpenParam.pszContent = "54-04-A6-C2-7C-2F";
status = GXOpenDevice(&stOpenParam, &hDevice);
//操 作 设 备 ： 控 制 、 采 集
//…
//关 闭 设 备
status = GXCloseDevice(hDevice);
}
```

GxOpenDevice 可用指定访问方式（独占、控制等）、打开方式（通过 IP、序列号、MAC、Index 等）打开相机。

### 13.6 控制相机功能

**整型相关接口：**
GXGetIntRange：查询范围，最小值、最大值、步长
GXGetInt：读取值
GXSetInt：设置值

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//获 取 整 型 范 围
GX_INT_RANGE stIntRange;
status = GXGetIntRange(hDevice, GX_INT_WIDTH, &stIntRange);
//读 取 当 前 值
int64_t nValue = 0;
status = GXGetInt(hDevice, GX_INT_WIDTH, &nValue);
//设 置 当 前 值 为 最 小 值
nValue = stIntRange.nMin;
status = GXSetInt(hDevice, GX_INT_WIDTH, nValue);
```

**浮点型相关接口**：
GXGetFloatRange：查询值的范围，最小值、最大值、步长、单位
GXGetFloat：读取
GXSetFloat：设置
**枚举型相关接口：**
GXGetEnumEntryNums：获取枚举项的个数
GXGetEnumDescription：查询枚举描述，枚举项的值及枚举项的描述
GXGetEnum：读取
GXSetEnum：设置
**布尔型相关接口：**
GXGetBool：读取
GXSetBool：设置
**字符串型相关接口：**
GXGetStringLength：查询字符串当前值的长度，单位字节
GXGetStringMaxLength：查询字符串的最大长度，单位字节
GXGetString：读取
GXSetString：设置
**块数据型相关接口**：
GXGetBufferLength：查询块儿数据的长度，用此长度申请内存，然后再调用 GXGetBuffer 读取数据
GXGetBuffer：读取
GXSetBuffer：设置
**命令型相关接口：**
GXSendCommand：发送命令

### 13.7 DQBuf 图像采集

调用 GXOpenDevice 接口打开设备后，==顺序调用 GXStreamOn 接口可使流开采和远端设备开采，此时循环调用 GXDQBuf 、 GXQBuf（GXDQAllBufs 、 GXQAllBufs 同理）可实现连续采集图像==。调用 GXQBuf接口将图像 buf 放回 GxIAPI 库后，不能再访问该图像 buf 指针。

```c++
//-------------------------------
//GXDQBuf 接 口 一 次 获 取 一 帧 图 像 ， 本 样 例 代 码 演 示 的 就 是 如 何 用 此 接 口 获 取 一 帧 图 像
//-------------------------------
#include "GxIAPI.h"
int main(int argc, char* argv[])
{
  GX_STATUS  status = GX_STATUS_SUCCESS;
  GX_DEV_HANDLE hDevice = NULL;
  uint32_t  nDeviceNum = 0;
  //初 始 化 库
  status = GXInitLib();
  if (status != GX_STATUS_SUCCESS)
  {
     return 0;
   }
   //枚 举 设 备 列 表
   status = GXUpdateDeviceList(&nDeviceNum, 1000);
   if ((status != GX_STATUS_SUCCESS) || (nDeviceNum <= 0))
   {
     return 0;
   }
   //打 开 设 备
   status = GXOpenDeviceByIndex(1, &hDevice);
   if (status == GX_STATUS_SUCCESS)
   {
   //定 义 GXDQBuf 的 传 入 参 数
    PGX_FRAME_BUFFER pFrameBuffer;
   //开 采
   status = GXStreamOn(hDevice);
   if (status == GX_STATUS_SUCCESS)
   {
   //调 用 GXDQBuf 取 一 帧 图 像
   status = GXDQBuf(hDevice, &pFrameBuffer, 1000);
   if (status == GX_STATUS_SUCCESS)
   {
   if (pFrameBuffer->nStatus == GX_FRAME_STATUS_SUCCESS)
   {
   //图 像 获 取 成 功
   //对 图 像 进 行 处 理 ...
   }
   //调 用 GXQBuf 将 图 像 buf 放 回 库 中 继 续 采 图
   status = GXQBuf(hDevice, pFrameBuffer);
   }
   }
   //停 采
   status = GXStreamOff(hDevice);
   }
   status = GXCloseDevice(hDevice);
   status = GXCloseLib();
   return 0;
}
```

### 13.8 回调图像采集

➢
图像处理回调函数——用户编写的图像处理函数，==GxIAPI 规定了函数的返回值、形参等内容==（见 GxIAPI库说明->类型->回调函数类型->GXCaptureCallBack）。
➢
注册回调函数——用户==调用 GxRegisterCaptureCallback 接口将用户编写的图像处理回调函数指针传给 GxIAPI 库==（见 GxRegisterCaptureCallback 接口的详细用法）。
➢
注销回调函数——用户==调用 GxUnregisterCaptureCallback 接口通知 GxIAPI 库释放掉用户注册的回调函数指针==。

```c++
#include"GxIAPI.h"
//图 像 回 调 处 理 函 数
static void GX_STDC OnFrameCallbackFun(GX_FRAME_CALLBACK_PARAM* pFrame)
{ 
  if (pFrame->status == GX_FRAME_STATUS_SUCCESS)
  {
  //对 图 像 进 行 某 些 操 作
  }
  return;
}
  int main(int argc, char* argv[])
{
  GX_STATUS status = GX_STATUS_SUCCESS;
  GX_DEV_HANDLE hDevice = NULL;
  GX_OPEN_PARAM  stOpenParam;
  uint32_tn DeviceNum = 0;
  //初 始 化 库
  status = GXInitLib();
  if (status!= GX_STATUS_SUCCESS)
  {
    return 0;
  }
  //枚 举 设 备 列 表
  status = GXUpdateDeviceList(&nDeviceNum, 1000);
  if ((status!= GX_STATUS_SUCCESS)||(nDeviceNum<= 0))
  {
     return 0;
  }
  //打 开 设 备
  stOpenParam.accessMode = GX_ACCESS_EXCLUSIVE;
  stOpenParam.openMode = GX_OPEN_INDEX;
  stOpenParam.pszContent = "1";
  status = GXOpenDevice(&stOpenParam, &hDevice);
  if (status == GX_STATUS_SUCCESS)
  {
  //注 册 图 像 处 理 回 调 函 数
  status = GXRegisterCaptureCallback(hDevice, NULL,OnFrameCallbackFun);
  //发 送 开 采 命 令
  status = GXSendCommand(hDevice, GX_COMMAND_ACQUISITION_START);
  //---------------------
  //
  //在 这 个 区 间 图 像 会 通 过 OnFrameCallbackFun 接 口 返 给 用 户
  //
  //---------------------
  //发 送 停 采 命 令
  status = GXSendCommand(hDevice, GX_COMMAND_ACQUISITION_STOP);
  //注 销 采 集 回 调
  status = GXUnregisterCaptureCallback(hDevice);
  }
  status = GXCloseDevice(hDevice);
  status = GXCloseLib();
  return 0;
}
```

另外用户还可以==通过 GxGetImage 接口来获取图像==，但是此获取图像的方式不能与回调取图同时使用.



## 14. 相机功能属性说明

### 14.1  设备控制

#### 14.1.1 设备信息

#####14.1.1.1 只读信息

打开设备之后可以使用==设备句柄==获取设备信息。

GX_STRING_DEVICE_VENDOR_NAME：            厂商名称
GX_STRING_DEVICE_MODEL_NAME：              设备型号
GX_STRING_DEVICE_FIRMWARE_VERSION：   设备固件版本
GX_STRING_DEVICE_VERSION：                        设备版本
GX_STRING_DEVICE_SERIAL_NUMBER：          设备序列号
GX_STRING_FACTORY_SETTING_VERSION：   出厂参数版本

```c++
//以 获 取 厂 商 名 称 为 例 ， 第 一 步 获 取 字 符 串 长 度 ， 第 二 步 按 照 获 取 的 长 度 分 配 buffer
//第 三 步 获 取 字 符 串 内 容
GX_STATUS status = GX_STATUS_SUCCESS;
size_t nSize = 0;
//首 先 获 取 字 符 串 允 许 的 最 大 长 度(此 长 度 包 含 结 束 符 ’\0’)
status = GXGetStringMaxLength(hDevice, GX_STRING_DEVICE_VENDOR_NAME, &nSize);
//根 据 获 取 的 长 度 申 请 内 存
char *pszText = new char[nSize];
status = GXGetString(hDevice, GX_STRING_DEVICE_VENDOR_NAME, pszText, &nSize);
```

##### 14.1.1.2  可读可写信息

GX_STRING_DEVICE_USERID：                          用户自定义名称

```c++
//以 获 取 用 户 标 识 为 例 ， 第 一 步 获 取 字 符 串 长 度 ， 第 二 步 按 照 获 取 的 长 度 分 配 buffer
//第 三 步 获 取 字 符 串 内 容
GX_STATUS status = GX_STATUS_SUCCESS;
size_t nSize = 0;
//首 先 获 取 字 符 串 允 许 的 最 大 长 度(此 长 度 包 含 结 束 符 ’\0’)
status = GXGetStringMaxLength(hDevice, GX_STRING_DEVICE_USERID, &nSize);
//根 据 获 取 的 长 度 申 请 内 存
char *pszText = newchar[nSize];
status = GXGetString(hDevice, GX_STRING_DEVICE_USERID, pszText, &nSize);
//设 置 用 户 自 定 义 名 称
status = GXSetString(hDevice, GX_STRING_DEVICE_USERID, "TestUserID");
```

#### 14.1.2 设备控制

设备复位：==还原设备打开状态为初始状态，同设备重新上电的状态。==调用完成后，主机端将失去与当前设备的连接。并且由于是在设备打开状态下才能设置该接口，因此==调用完成之后，需要开发人员主动调用 GXCloseDevice 接口关闭设备，以释放相应的内存资源==。
时间戳频率：只读信息，它表示时间戳计数的频率，其值为 125000000Hz。
时间戳锁存：==锁取当前的时间戳值==，即从设备开始上电到时间戳锁存命令调用时经历的时间值，该时间值需要通过“时间戳锁存值”来读取。
重置时间戳：复位时间戳计数器，从 0 开始重新计数。
重置时间戳锁存：先锁取当前的时间戳值，然后复位时间戳计数器，从 0 开始重新计数。

**相关参数**
GX_COMMAND_DEVICE_RESET：                        设备复位
GX_INT_TIMESTAMP_TICK_FREQUENCY：         时间戳频率
GX_COMMAND_TIMESTAMP_LATCH：              时间戳锁存
GX_COMMAND_TIMESTAMP_RESET：               重置时间戳
GX_COMMAND_TIMESTAMP_LATCH_RESET： 重置时间戳锁存
GX_INT_TIMESTAMP_LATCH_VALUE：               时间戳锁存值

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//发 送 重 置 时 间 戳 命 令
emStatus = GXSendCommand(hDevice, GX_COMMAND_TIMESTAMP_RESET);
//发 送 设 备 复 位 命 令
emStatus = GXSendCommand(hDevice, GX_COMMAND_DEVICE_RESET);
```

###14.2 图像格式

#### 14.2.1 感兴趣区域

**名词解释**
ROI：感兴趣区域（region of interest），相对于相机传感器的一个可配置的矩形选择区域，相机只输出被选择区域的数据，在矩形框选择范围之外的数据将被忽略。

**相关参数**
GX_INT_SENSOR_WIDTH：         传感器宽度，以像素为单位
GX_INT_SENSOR_HEIGHT：       传感器高度，以像素为单位
GX_INT_WIDTH_MAX：               图像最大宽度，以像素为单位
GX_INT_HEIGHT_MAX ：             图像最大高度，以像素为单位
GX_INT_WIDTH：                         感兴趣区域的宽度，以像素为单位
GX_INT_HEIGHT：                        感兴趣区域的高度，以像素为单位
GX_INT_OFFSET_X：                    相对于 sensor 左上角的 x 方向偏移量，以像素为单位
GX_INT_OFFSET_Y：                     相对于 sensor 左上角的 y 方向偏移量，以像素为单位

```c++
//设 置 一 个 offset 偏 移 为 （0,0） ，600x400 尺 寸 的 区 域
GX_STATUS status = GX_STATUS_SUCCESS;
int64_t nWidth= 600;
int64_t nHeight= 400;
int64_t nOffsetX = 0;
int64_t nOffsetY = 0;
status = GXSetInt(hDevice, GX_INT_WIDTH, nWidth);
status = GXSetInt(hDevice, GX_INT_HEIGHT, nHeight);
status = GXSetInt(hDevice, GX_INT_OFFSET_X, nOffsetX);
status = GXSetInt(hDevice, GX_INT_OFFSET_Y, nOffsetY);
```

**注意事项**

1) 有两对属性会影响到 ROI 的最大尺寸：
GX_INT_SENSOR_WIDTH
GX_INT_SENSOR_HEIGHT
决定图像传感器的有效分辨率，决定了可用的像素点的个数，它的值是固定的。在默认模式下（没有binning，没有 decimation，没有 ROI），图像的大小等于 sensor _width X sensor_ height。

​       GX_INT_WIDTH_MAX
​       GX_INT_HEIGHT_MAX
​       这两个值决定了 ROI 当前可用的最大尺寸，ROI 的宽的最大值可能被 binning 或者 decimation 影响。
​       在默认模式下
​    （没有 binning，没有 decimation）， width_max X height_max = sensor_ width X sensor_ height。

2) 为了保证 ROI 的有效性，ROI 的四个属性之间需要遵守关系公式，如下：
OffsetX + Width <= WidthMax(当前图像的最大宽)
OffsetY+Height<=HeightMax(当前图像的最大高)
上面两个公式说明了四个属性的最大值是动态变化的，比如调整 Width 的值，会影响 OffsetX 的可调最大值，这种联动关系 GxIAPI 内部已经实现。

####14.2.2 图像分辨率

**名词解释**
Binning 和 Decimation 是==直接作用于相机传感器内部，在相机出图之前进行的二次抽样处理操作==，这两个功能==通过修改水平或者垂直方向的分辨率达到提高帧率的效果==，它和 ROI 的差别是，==ROI 是对视野进行裁剪，而 Binning 和 Decimation 则是对整个图像抽行或者合并处理，并不影响这个视野的范围==。
➢ Binning：它是一种图像输出模式，分为水平像素 Binning 和垂直像素 Binning。在该模式下，根据用户选择的合并模式将相邻像元的电荷相加（Sum），或者取相邻像元电荷的平均值（Average），以一个像素的模式进行输出。使用 Binning 优点是能将几个像素联合起来作为一个像素使用，提高灵敏度，输出速度，降低分辨率，当行和列同时采用 Binning 时，图像的纵横比并不改变，当采用 2:2 Binning，图像的解析度将减少 75%。
➢ Decimation：像元跳跃式输出，挑选第 N 个（水平或者垂直）像元进行输出，其他的像元均忽略。
**相关参数**
GX_INT_BINNING_HORIZONTAL：                                 水平像素 Binning
GX_INT_BINNING_VERTICAL：                                        垂直像素 Binning
GX_INT_DECIMATION_HORIZONTAL：                          水平抽取参数
GX_INT_DECIMATION_VERTICAL：                                 垂直抽取参数
GX_ENUM_BINNING_HORIZONTAL_MODE：               水平像素 Binning 模式，
                                                                                              枚举值参考 GX_BINNING_HORIZONTAL_MODE_ENTRY
GX_ENUM_BINNING_VERTICAL_MODE：                       垂直像素 Binning 模式，
                                                                                               枚举值参考 GX_BINNING_VERTICAL_MODE_ENTRY

```c++
//配 置 一 个 2x2 的 Binning 和 2x2 的 Decimation
GX_STATUS status = GX_STATUS_SUCCESS;
int64_t nBinningH = 2;
int64_t nBinningV = 2;
int64_t nDecimationH= 2;
int64_t nDecimationV= 2;
//设 置 水 平 和 垂 直 Binning 模 式 为 Sum 模 式
status = GXSetEnum(hDevice,GX_ENUM_BINNING_HORIZONTAL_MODE,
GX_BINNING_HORIZONTAL_MODE_SUM);
status = GXSetEnum(hDevice,GX_ENUM_BINNING_VERTICAL_MODE,GX_BINNING_VERTICAL_MODE_SUM);
status = GXSetInt(hDevice, GX_INT_BINNING_HORIZONTAL, nBinningH);
status = GXSetInt(hDevice, GX_INT_BINNING_VERTICAL, nBinningV);
status = GXSetInt(hDevice, GX_INT_DECIMATION_HORIZONTAL, nDecimationH);
status = GXSetInt(hDevice, GX_INT_DECIMATION_VERTICAL, nDecimationV);
```

### 14.3  数据格式

**名词解释**
➢ 数据位深：==每一个像元灰度值所占的数据位数==，例如 8 位数据表示的灰度值范围是 0~255。RAW 数据格式是 CMOS 或者 CCD 图像传感器将捕捉的光信号转化为数字信号的原始数据格式，这种转换没有经过任何压缩。RAW8 表示输出图像数据位深为 8bit，RAW12 表示输出的图像数据位深为 12bit。
➢ Bayer 颜色转换：==Bayer 类型是 RAW 图像数据的排列格式，图像数据进行处理或者显示时，需要将其通过插值转换为 24 位的 RGB 真彩色图像数据。==下面介绍了一种简单的插值算法：

**相关参数**
GX_ENUM_PIXEL_SIZE：                                     数据位深，枚举值参考 GX_PIXEL_SIZE_ENTRY
GX_ENUM_PIXEL_COLOR_FILTER：                  Bayer 格式，枚举值参考 GX_PIXEL_COLOR_FILTER_ENTRY
GX_ENUM_PIXEL_FORMAT：                             数据格式，枚举值参考 GX_PIXEL_FORMAT_ENTRY
数据格式：PixelFormat 共 8Byte，32bit。      将多种信息集中到一起组成一个单独的信息量。最高两个字节代表                      了色彩样式（彩色或者黑白），紧接着的两个字节表示数据位深（8 位、10 位等），最低 4 个字节表示编码序号（参考 GX_PIXEL_FORMAT_ENTRY）。

```c++
//使 用 GXGetEnumEntryNums、GXGetEnumDescription 两 个 接 口
//查 询 当 前 相 机 支 持 的 GX_ENUM_PIXEL_FORMAT 类 型
//参 考 相 关 接 口 说 明 部 分 ， 此 处 省 略
GX_STATUS status = GX_STATUS_SUCCESS;
//读 取 当 前 pixelformat
int64_t nPixelFormat = 0;
status = GXGetEnum(hDevice, GX_ENUM_PIXEL_FORMAT, &nPixelFormat);
//设 置 pixelformat 为 bayer 格 式 为 BG 的 位 深 数 据
nPixelFormat = GX_PIXEL_FORMAT_BAYER_BG10;
status = GXSetEnum(hDevice, GX_ENUM_PIXEL_FORMAT, nPixelFormat);
//读 取 当 前 pixelsize
int64_t nPixelSize = 0;
status = GXGetEnum(hDevice, GX_ENUM_PIXEL_SIZE, &nPixelSize);
//读 取 当 前 colorfilter
int64_t nColorFilter = 0;
status = GXGetEnum(hDevice, GX_ENUM_PIXEL_COLOR_FILTER, &nColorFilter);
```

### 14.4 帧信息控制

**名词解释**
当开启帧信息后，帧信息会以如下格式==追加到图像数据的尾部==，用来标识当前图像的信息。

**相关参数**
GX_BOOL_CHUNKMODE_ACTIVE：        帧信息使能
GX_ENUM_CHUNK_SELECTOR：             帧信息项选择
GX_BOOL_CHUNK_ENABLE：                  单项帧信息使能

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//设 置 帧 信 息 模 式 为 使 能 状 态
status = GXSetBool(hDevice, GX_BOOL_CHUNKMODE_ACTIVE, true);
//查 询 当 前 相 机 支 持 哪 些 帧 信 息,请 参 见 GXGetEnumDescription 接 口 的 用 法
//本 样 例 假 设 当 前 相 机 支 持 所 有 类 型 的 帧 信 息
//选 择 帧 号
status = GXSetEnum(hDevice, GX_ENUM_CHUNK_SELECTOR,GX_CHUNK_SELECTOR_CHUNK_FRAME_ID);
//设 置 帧 号 为 使 能 状 态
status = GXSetBool(hDevice, GX_BOOL_CHUNK_ENABLE, true);
```

**注意事项**
C 软件接口开放了帧信息的控制接口，但是开放没有获取帧信息的接口，如果用户需要解析帧信息，需要按照上图中的格式，从图像数据的尾部开始解析，具体解析方法和各相机的帧信息排列顺序，请咨询技术支持。



## 15. 控制

###15.1 采集

**名词解释**
➢ 采集模式：设置==相机的出图模式==，它主要定义了相机在一个完整的采集过程中出图的个数。所谓一个完整的采集过程指的是从发送开采命令开始到发送停采命令结束。
➢ 采多帧帧数：当采集模式为采多帧模式的时候，这个参数决定了此模式下相机在一个完整的采集过程中出图的个数。
➢ 采集速度级别：==直接控制相机帧率==。采集速度级别越大，帧率越大；采集速度级别越小，帧率越小。
➢ 高速连拍帧数：一次触发采集多帧图像。例如，如果“高速连拍帧数”参数设置为 3，则相机会在一个帧高速连拍开始触发信号后自动输出 3 张图像。
➢ 采 集 状 态 选 择 ： 采 集 状 态 是 ==用 来 确 定 相 机 是 否 在 等 待 触 发 信 号== 。 有 FrameTriggerWait 和AcquisitionTriggerWait 两种模式。FrameTriggerWait：选择此状态后，可以通过查询采集功能状态确定相机是否正在等待帧起始触发信号，AcquisitionTriggerWait：选择此状态后，可以通过查询采集状态功能确定相机是否正在等待多帧采集状态下的触发信号。功能仅在触发模式下使用，对连续采集模式无影响。
➢ 采集状态：该功能码配合采集状态选择功能使用，具体请参考采集状态选择。在非采集期间（开始采集前，停止采集之后），非触发模式下，查询的值没有任何意义。

**相关参数**
GX_ENUM_ACQUISITION_MODE：                         采集模式，枚举值参考 GX_ACQUISITION_MODE_ENTRY
GX_COMMAND_ACQUISITION_START：                开采命令
GX_COMMAND_ACQUISITION_STOP：                  停采命令
GX_INT_ACQUISITION_FRAME_COUNT：               采多帧帧数
GX_INT_ACQUISITION_SPEED_LEVEL：                   采集速度级别
GX_INT_ACQUISITION_BURST_FRAME_COUNT：  高速连拍帧数
GX_ENUM_ACQUISITION_STATUS_SELECTOR：    采集状态选择，参考
                                                                                          GX_ACQUISITION_STATUS_SELECTOR_ENTRY
GX_BOOL_ACQUISITION_STATUS：采集状态

**控制流程**

采集模式分为：   连续模式  ，  多帧模式 ， 单帧模式

多（单）帧模式下不需要停采命令。

触发模式可选  True    Flase

触发模式就是触发以下动一次



![](/home/peter/图片/采集流程1.png)

![](/home/peter/图片/采集流程2.png)

![](/home/peter/图片/采集流程3.png)

![](/home/peter/图片/采集流程4.png)

![](/home/peter/图片/采集流程5.png)



```c++
#include "GxIAPI.h"
//图 像 回 调 处 理 函 数
static void GX_STDCOnFrameCallbackFun(GX_FRAME_CALLBACK_PARAM* pFrame)
{
  if (pFrame->status == 0)
  {
    //对 图 像 进 行 某 些 操 作
  }
  return;
}
//初始化库，枚举相机，打开相机，设置采集模式，注册回调函数，发送开采命令，发送停采命令，注销回调函数，关闭相机，反初始化库
int main(intargc, char* argv[])
{
  GX_STATUS status = GX_STATUS_SUCCESS;
  GX_DEV_HANDLE hDevice = NULL;
  GX_OPEN_PARAM stOpenParam;
  uint32_t nDeviceNum = 0;
  //初 始 化 库
  status = GXInitLib();
  if (status != GX_STATUS_SUCCESS)
  {
    return 0;
  }
  //枚 举 设 备 列 表
  status = GXUpdateDeviceList(&nDeviceNum, 1000);
  if ((status!= GX_STATUS_SUCCESS)||(nDeviceNum<= 0))
  {
    return 0;
  }
  //打 开 设 备
  stOpenParam.accessMode = GX_ACCESS_EXCLUSIVE;
  stOpenParam.openMode = GX_OPEN_INDEX;
  stOpenParam.pszContent = "1";
  status = GXOpenDevice(&stOpenParam, &hDevice);
  if (status == GX_STATUS_SUCCESS)
  {
  //设 置 采 集 模 式 。 一 般 相 机 的 默 认 采 集 模 式 为 连 续 模 式 。
  //int64_t nAcqMode = GX_ACQ_MODE_CONTINUOUS;
  //status = GXSetEnum(hDevice, GX_ENUM_ACQUISITION_MODE, nAcqMode);
  //注 册 图 像 处 理 回 调 函 数
  status = GXRegisterCaptureCallback(hDevice, NULL, OnFrameCallbackFun);
  //发 送 开 采 命 令
  status = GXSendCommand(hDevice, GX_COMMAND_ACQUISITION_START);
  //---------------------
  //
  //在 这 个 区 间 图 像 会 通 过 OnFrameCallbackFun 接 口 返 给 用 户
  //
  //---------------------
  //发 送 停 采 命 令 
  status = GXSendCommand(hDevice, GX_COMMAND_ACQUISITION_STOP);
  //注 销 采 集 回 调
  status = GXUnregisterCaptureCallback(hDevice);
  }
  status = GXCloseDevice(hDevice);
  status = GXCloseLib();
  return 0;
}    
```

### 15.2 触发

**名词解释**
➢ 触发源：选择触发信号的来源。软触发或者外触发。
➢ 触发模式：决定触发信号是否有效。ON 表示触发有效；OFF 表示触发无效。
➢ 触发极性：触发激活方式，分为上升沿有效或者下降沿有效。
➢ 软触发命令：软件模拟触发信号。

**相关参数**

GX_ENUM_TRIGGER_MODE：                        触发模式，枚举值参考 GX_TRIGGER_MODE_ENTRY
GX_COMMAND_TRIGGER_SOFTWARE：      软触发命令
GX_ENUM_TRIGGER_ACTIVATION：             触发极性，枚举值参考 GX_TRIGGER_ACTIVATION_ENTRY
GX_ENUM_TRIGGER_SWITCH：                     外触发开关,参考 GX_TRIGGER_SWITCH_ENTRY
GX_ENUM_TRIGGER_SOURCE：                    触发源，枚举值参考 GX_TRIGGER_SOURCE_ENTRY
GX_ENUM_TRIGGER_SELECTOR：                触发类型选择，参考 GX_TRIGGER_SELECTOR_ENTRY
GX_FLOAT_TRIGGER_DELAY：                       触发延迟

```c++
#include "GxIAPI.h"
//图 像 回 调 处 理 函 数
static void GX_STDC OnFrameCallbackFun(GX_FRAME_CALLBACK_PARAM* pFrame)
{
  if (pFrame->status == 0)
  {
    //对 图 像 进 行 某 些 操 作
  }
  return;
}
int main(int argc, char* argv[])
{
    GX_STATUS status = GX_STATUS_SUCCESS;
    GX_DEV_HANDLE hDevice = NULL;
    GX_OPEN_PARAM stOpenParam;
    uint32_t nDeviceNum = 0;
    //初 始 化 库
    status = GXInitLib();
    if (status!= GX_STATUS_SUCCESS)
    {
      return 0;
    }
    //枚 举 设 备 列 表
    status = GXUpdateDeviceList(&nDeviceNum, 1000);
    if ((status!= GX_STATUS_SUCCESS)||(nDeviceNum<= 0))
    {
        return 0;
    }
    //打 开 设 备
    stOpenParam.accessMode = GX_ACCESS_EXCLUSIVE;
    stOpenParam.openMode = GX_OPEN_INDEX;
    stOpenParam.pszContent = "1";
    status = GXOpenDevice(&stOpenParam, &hDevice);
    if (status == GX_STATUS_SUCCESS)
    {
    //设 置 触 发 模 式 为 ON
    status =GXSetEnum(hDevice,GX_ENUM_TRIGGER_MODE, GX_TRIGGER_MODE_ON);
    //设 置 触 发 激 活 方 式 为 上 升 沿
    status = GXSetEnum(hDevice,GX_ENUM_TRIGGER_ACTIVATION,GX_TRIGGER_ACTIVATION_RISINGEDGE);
    //注 册 图 像 处 理 回 调 函 数
    status = GXRegisterCaptureCallback(hDevice, NULL, OnFrameCallbackFun);
    //发 送 开 采 命 令
    status = GXSendCommand(hDevice, GX_COMMAND_ACQUISITION_START);
    //---------------------
    //
    //在 发 送 停 采 命 令 前 如 果 产 生 了 有 效 触 发 ， 那 么 图 像
    //会 通 过 OnFrameCallbackFun 接 口 返 给 用 户
    //---------------------
    //发 送 停 采 命 令
    status = GXSendCommand(hDevice, GX_COMMAND_ACQUISITION_STOP);
    //注 销 采 集 回 调
    status = GXUnregisterCaptureCallback(hDevice);
    }
    status = GXCloseDevice(hDevice);
    status = GXCloseLib();
    return 0;
}
```

### 15.3 高级功能

**名词解释**
➢ 上升沿触发滤波值：上升沿脉冲宽度如果小于此滤波值，那么相机将不会处理这样的触发信号。只
有当上升沿脉冲宽度大于、等于此滤波值的时候，才会产生有效触发信号。
➢ 下降沿触发滤波值：下降沿脉冲宽度如果小于此滤波值，那么相机将不会处理这样的触发信号。只
有当下降沿脉冲宽度大于、等于此滤波值的时候，才会产生有效触发信号。

**相关参数**
GX_FLOAT_TRIGGER_FILTER_RAISING：上升沿触发滤波值
GX_FLOAT_TRIGGER_FILTER_FALLING：下降沿触发滤波值

```c++
//获 取 上 升 沿 滤 波 设 置 范 围
GX_FLOAT_RANGE raisingRange;
status = GXGetFloatRange(hDevice, GX_FLOAT_TRIGGER_FILTER_RAISING, &raisingRange);
//设 置 上 升 沿 滤 波 最 小 值
status = GXSetFloat(hDevice, GX_FLOAT_TRIGGER_FILTER_RAISING,raisingRange.dMin);
//设 置 上 升 沿 滤 波 最 大 值
status = GXSetFloat(hDevice, GX_FLOAT_TRIGGER_FILTER_RAISING, raisingRange.dMax);
//获 取 当 前 上 升 沿 滤 波 值
double dRaisingValue = 0;
status = GXGetFloat(hDevice, GX_FLOAT_TRIGGER_FILTER_RAISING, &dRaisingValue);
//获 取 下 降 沿 滤 波 设 置 范 围
GX_FLOAT_RANGE fallingRange;
status = GXGetFloatRange(hDevice, GX_FLOAT_TRIGGER_FILTER_FALLING, &fallingRange);
//设 置 下 降 沿 滤 波 最 小 值
status = GXSetFloat(hDevice, GX_FLOAT_TRIGGER_FILTER_FALLING, fallingRange.dMin);
//设 置 下 降 沿 滤 波 最 大 值
status = GXSetFloat(hDevice, GX_FLOAT_TRIGGER_FILTER_FALLING, fallingRange.dMax);
//获 取 当 前 下 降 沿 滤 波 值
double dFallingValue = 0;
status = GXGetFloat(hDevice, GX_FLOAT_TRIGGER_FILTER_FALLING, &dFallingValue);
```

### 15.4 曝光

**名词解释**
曝光模式：曝光的不同工作方式，Timed 模式的时候，才可以使用 GX_FLOAT_EXPOSURE_TIME、
GX_ENUM_EXPOSURE_AUTO。
曝光时间：曝光时间即快门速度，指的是传感器的快门从打开到关闭的时间间隔，在这个时间间隔内被摄物体可以在传感器上留下影像。减小曝光时间图像变暗，增大曝光时间图像变亮。
曝光延迟：==曝光延迟功能可以有效解决闪光灯延时问题==。绝大部分闪光灯从触发到点亮至少有几十微秒以上的延时，当相机工作在小曝光模式下，闪光灯的补光效果就会受影响。通过闪光灯信号和实际曝光开始的延时来实现曝光延迟。

**相关参数**
GX_ENUM_EXPOSURE_MODE：曝光模式，枚举值参考 GX_EXPOSURE_MODE_ENTRY
GX_FLOAT_EXPOSURE_TIME：曝光时间
GX_ENUM_EXPOSURE_AUTO：自动曝光使能控制，枚举值参考 GX_EXPOSURE_AUTO_ENTRY
GX_FLOAT_EXPOSURE_DELAY：曝光延迟

```c++
//获 取 曝 光 调 节 范 围
GX_FLOAT_RANGE shutterRange;
double dExposureValue = 2.0;
status = GXGetFloatRange(hDevice, GX_FLOAT_EXPOSURE_TIME, &shutterRange);
//设 置 最 小 曝 光 值
status = GXSetFloat(hDevice, GX_FLOAT_EXPOSURE_TIME, shutterRange.dMin);
//设 置 最 大 曝 光 值
status = GXSetFloat(hDevice, GX_FLOAT_EXPOSURE_TIME, shutterRange.dMax);
//设 置 连 续 自 动 曝 光
status = GXSetEnum(hDevice, GX_ENUM_EXPOSURE_AUTO, GX_EXPOSURE_AUTO_CONTINUOUS);
//设 置 曝 光 延 迟 为 2us
status = GXSetFloat(hDevice, GX_FLOAT_EXPOSURE_DELAY, dExposureValue);
```

注意事项:当外部光源为自然光或者直流电光源时对曝光时间无特殊要求，但是当外部光源为交流电光源时，==曝光时间需要与外部光源的交流频率同步==（50Hz 光照环境下，曝光时间必须是 1/100s 的整倍数，60Hz 光照环境下，曝光时间必须是 1/120s 的整倍数）。

### 15.5 传输控制

**名词解释**
当多个相机和主机通过交换机连接时，如果同时触发这些相机采集图像，在传输图像由于交换机的瞬时带宽过大，存储能力有限，会出现数据丢失问题。因此需要使用帧传输延迟避免该问题发生。在触发模式下，通过设置传输控制模式为“用户控制”，==当相机接到软触发命令或者硬触发信号并完成图像采集以后，将图像保存在相机内部的帧存中，等待主机端发送“开始传输”命令以后，相机将采集到的图像传输到主机端。==传输延迟时间由主机端决定。在多个相机同时触发的时候，可以为每台相机设置不同的传输延迟时间，以避免交换机的瞬时带宽过大。

**相关参数**
GX_ENUM_TRANSFER_CONTROL_MODE：传输控制模式
GX_ENUM_TRANSFER_OPERATION_MODE：传输操作模式
GX_COMMAND_TRANSFER_START：开始传输
GX_INT_TRANSFER_BLOCK_COUNT：传输帧数

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//前 提 必 须 确 保 触 发 模 式 为 开 启 状 态
emStatus = GXSetEnum(hDevice, GX_ENUM_TRIGGER_MODE, GX_TRIGGER_MODE_ON);
//设 置 传 输 控 制 模 式 为 用 户 控 制 模 式
emStatus = GXSetEnum(hDevice, GX_ENUM_TRANSFER_CONTROL_MODE,GX_ENUM_TRANSFER_CONTROL_MODE_USERCONTROLED);
//设 置 传 输 操 作 模 式 为 指 定 发 送 帧 数
emStatus = GXSetEnum(hDevice, GX_ENUM_TRANSFER_OPERATION_MODE,GX_ENUM_TRANSFER_OPERATION_MODE_MULTIBLOCK);
//设 置 每 次 命 令 输 出 帧 数 帧
emStatus = GXSetInt(hDevice, GX_INT_TRANSFER_BLOCK_COUNT, 1);
//开 采 之 后 发 送 软 触 发 信 号 （ 或 者 外 触 发 ）
emStatus = GXSendCommand(hDevice, GX_COMMAND_ACQUISITION_START);
emStatus = GXSendCommand(hDevice, GX_COMMAND_TRIGGER_SOFTWARE);
//触 发 出 图 之 后 发 送 传 输 命 令
emStatus = GXSendCommand(hDevice, GX_COMMAND_TRANSFER_START);
```

### 15.6帧存机制

**名词解释**
帧存覆盖：当相机向内部帧存写入数据的平均带宽大于读出数据的平均带宽时，会出现帧存满的情况。如果帧存满后继续写入图像数据，将覆盖以前帧存里的图像数据。
**相关参数**
GX_BOOL_FRAMESTORE_COVER_ACTIVE：帧存覆盖使能

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//使 能 帧 存 覆 盖
status = GXSetBool(m_hDevice, GX_BOOL_FRAMESTORE_COVER_ACTIVE, true);
//禁 用 帧 存 覆 盖
status = GXSetBool(m_hDevice, GX_BOOL_FRAMESTORE_COVER_ACTIVE, false);
```

### 15.7 帧率控制

**名词解释**
➢ 采集帧率调节模式：控制是否开启帧率控制模式，on 为启动帧率控制，off 为不启用帧率控制。详见 GxIAPI.h 定义 GX_ACQUISITION_FRAME_RATE_MODE_ENTRY。
➢ 采集帧率：==期望的相机采集帧率==。
➢ 当前采集帧率：实际运行时的采集帧率。

相关参数
GX_ENUM_ACQUISITION_FRAME_RATE_MODE：     采集帧率调节模式
GX_FLOAT_ACQUISITION_FRAME_RATE：                  采集帧率
GX_FLOAT_CURRENT_ACQUISITION_FRAME_RATE：当前采集帧率

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//使 能 采 集 帧 率 调 节 模 式
status = GXSetEnum(m_hDevice, GX_ENUM_ACQUISITION_FRAME_RATE_MODE,
GX_ACQUISITION_FRAME_RATE_MODE_ON);
//设 置 采 集 帧 率,假 设 设 置 为 10.0， 用 户 按 照 实 际 需 求 设 置 此 值
status = GXSetFloat(m_hDevice, GX_FLOAT_ACQUISITION_FRAME_RATE, 10.0);
```

**注意事项**
如果 GX_FLOAT_ACQUISITION_FRAME_RATE 设置的过大，超过了相机实际运行能力，相机会以其自身可达到的最大帧率运行，即 GX_FLOAT_CURRENT_ACQUISITION_FRAME_RATE 当前采集帧率的值（帧率受曝光、ROI 等功能的影响）。

##16.数字 IO

###16.1 引脚控制

**相关参数**
GX_ENUM_LINE_SELECTOR：                      引脚选择
GX_ENUM_LINE_MODE：                             引脚方向
GX_BOOL_LINE_INVERTER：                        引脚电平反转
GX_ENUM_LINE_SOURCE：                          引脚输出源
GX_BOOL_LINE_STATUS：                            引脚状态
GX_INT_LINE_STATUS_ALL：                         所有引脚的状态
GX_ENUM_USER_OUTPUT_SELECTOR：     用户自定义输出选择
GX_BOOL_USER_OUTPUT_VALUE：             用户自定义输出值
GX_FLOAT_PULSE_WIDTH：                          用户自定义脉冲宽度

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//举 例 引 脚 选 择 为 Line2
emStatus = GXSetEnum(hDevice, GX_ENUM_LINE_SELECTOR, GX_ENUM_LINE_SELECTOR_LINE2);
//设 置 引 脚 方 向 为 输 出
emStatus = GXSetEnum(hDevice, GX_ENUM_LINE_MODE, GX_ENUM_LINE_MODE_OUTPUT);
//可 选 操 作 引 脚 电 平 反 转
//emStatus = GXSetBool(hDevice, GX_BOOL_LINE_INVERTER, true);
//如 果 设 置 输 出 源 为 闪 光 灯,则 如 下 代 码
emStatus = GXSetEnum(hDevice, GX_ENUM_LINE_SOURCE, GX_ENUM_LINE_SOURCE_STROBE);
//如 果 设 置 输 出 源 为 用 户 自 定 义 输 出,则 如 下 代 码
emStatus = GXSetEnum(hDevice, GX_ENUM_LINE_SOURCE,
GX_ENUM_LINE_SOURCE_USEROUTPUT0);
//还 可 以 设 置 用 户 自 定 义 输 出 值 ， 如 下 代 码
emStatus = GXSetEnum(hDevice,GX_ENUM_USER_OUTPUT_SELECTOR,
GX_USER_OUTPUT_SELECTOR_OUTPUT0);
emStatus = GXSetBool(hDevice, GX_BOOL_USER_OUTPUT_VALUE,true);
//查 看 引 脚 Line2 的 状 态 ， 因 为 当 前 LineSelector 选 择 的 是 Line2， 直 接 查 询 当 前 值 即 可
bool bLineStatus = true;
emStatus = GXGetBool(hDevice, GX_BOOL_LINE_STATUS, &bLineStatus);
//查 看 当 前 所 有 引 脚 状 态
int64_t nAllLineStatus = 0;
emStatus = GXGetInt(hDevice, GX_INT_LINE_STATUS_ALL, &nAllLineStatus);
```

### 16.2 USB2.0 相机 IO 控制

USB2.0 的 IO 控制比较特殊，与上面一节展示“引脚控制”操作不是同一个操作流程，USB2.0 的 IO 控制涉及到以下三个功能：
**名词解释**
➢ 用户 IO 输出模式：分为闪光灯模式和用户自定义模式。闪光灯模式：在此模式下相机发送触发信号来激活闪光灯（触发信号分为上升沿、下降沿两种）；用户自定义模式：在此模式下用户可以自己设定相机恒定的输出电平来做特别处理，比如控制 LED 灯（电平分为高电平或者低电平）。
➢ 输出信号极性：当输出信号模式为闪光灯模式的时候代表上升沿或者下降沿；当输出信号模式为用户自定义模式的时候代表高电平或者低电平。
➢ 闪光灯开关：此开关仅在输出模式为闪光灯模式下才起作用，当设置为开的时候输出触发信号，当设置为关的时候不输出闪光灯信号。

**相关参数**
GX_ENUM_USER_OUTPUT_MODE：用户 IO 输出模式，枚举值参考 GX_USER_OUTPUT_MODE_ENTRY
【USB2.0 相机专用】

GX_BOOL_USER_OUTPUT_VALUE：用户自定义输出值【如果是 USB2.0 相机，此值表示输出信号极性：当输出信号模式为闪光灯模式的时候代表上升沿或者下降沿；当输出信号模式为用户自定义模式的时候代表高电平或者低电平】

GX_ENUM_STROBE_SWITCH：闪光灯开关，枚举值参考 GX_STROBE_SWITCH_ENTRY【USB2.0 相机专用】

![](/home/peter/图片/IO控制流图.png)

```c++
#include "GxIAPI.h"
int main(int argc, char* argv[])
{
  GX_STATUS status = GX_STATUS_SUCCESS;
  GX_DEV_HANDLE hDevice = NULL;
  GX_OPEN_PARAM stOpenParam;
  uint32_t nDeviceNum = 0;
  //初 始 化 库
  status = GXInitLib();
  if (status!= GX_STATUS_SUCCESS)
  {
    return 0;
  }
  //枚 举 设 备 列 表
  status = GXUpdateDeviceList(&nDeviceNum, 1000);
  if ((status!= GX_STATUS_SUCCESS)||(nDeviceNum<= 0))
  {
     return 0;
   }
  //打 开 设 备
  stOpenParam.accessMode = GX_ACCESS_EXCLUSIVE;
  stOpenParam.openMode = GX_OPEN_INDEX;
  stOpenParam.pszContent = "1";
  status = GXOpenDevice(&stOpenParam, &hDevice);
  if (status == GX_STATUS_SUCCESS)
  {
    //设 置 输 出 信 号 极 性 为 高
    status = GXSetBool(hDevice,GX_BOOL_USER_OUTPUT_VALUE,true);
    //设 置 输 出 模 式 为 闪 光 灯 模 式
    status = GXSetEnum(hDevice,GX_ENUM_USER_OUTPUT_MODE,GX_USER_OUTPUT_MODE_STROBE);
    //打 开 闪 光 灯 开 关
    status = GXSetEnum(hDevice,GX_ENUM_STROBE_SWITCH,GX_STROBE_SWITCH_ON);
   }
status = GXCloseDevice(hDevice);
GXCloseLib();
return 0;
}
```



## 17 . 模拟控制

### 17.1 增益

增益是用来提高象素值的一个乘法因子，起到的效果就是增加图像亮度。在一些特定的条件下（外部环境等）sensor 达不到期望的饱和度，所以需要调节增益。当然提高增益也会提高噪声，所以提高增益并没有改善实际象素的动态范围。所以当需要提高图像亮度的时候首先考虑调节曝光时间，只有当曝光时间调节已经无法满足要求的时候再去调节增益。

**名词解释**
➢ 增益通道选择：调节增益之前需要先选择通道，一般分为 ALL、 Red、 Green、 Blue 四种通道类型。
➢ 增益控制方式：分为手动调节方式和自动调节方式两种。

**相关参数**

GX_ENUM_GAIN_SELECTOR：             增益通道选择，枚举值参考           GX_GAIN_SELECTOR_ENTRY
GX_FLOAT_GAIN：                                   增益值
GX_ENUM_GAIN_AUTO：                       自动增益使能控制，枚举值参考 GX_GAIN_AUTO_ENTRY

```c++
//手 动 增 益 调 节------------------------
//使 用 GXGetEnumEntryNums、GXGetEnumDescription 两 个 接 口
//查 询 当 前 相 机 支 持 的 GX_ENUM_GAIN_SELECTOR 类 型
//参 考 接 口 说 明 部 分 ， 此 处 省 略
//假 设 当 前 相 机 支 持 GX_GAIN_SELECTOR_ALL
//选 择 增 益 通 道 类 型
status = GXSetEnum(hDevice, GX_ENUM_GAIN_SELECTOR, GX_GAIN_SELECTOR_ALL);
//status= GXSetEnum(hDevice, GX_ENUM_GAIN_SELECTOR, GX_GAIN_SELECTOR_RED);
//status= GXSetEnum(hDevice, GX_ENUM_GAIN_SELECTOR, GX_GAIN_SELECTOR_GREEN);
//status= GXSetEnum(hDevice, GX_ENUM_GAIN_SELECTOR, GX_GAIN_SELECTOR_BLUE);
//获 取 增 益 调 节 范 围
GX_FLOAT_RANGE gainRange;
status = GXGetFloatRange(hDevice, GX_FLOAT_GAIN, &gainRange);
//设 置 最 小 增 益 值
status = GXSetFloat(hDevice, GX_FLOAT_GAIN, gainRange.dMin);
//设 置 最 大 增 益 值
status = GXSetFloat(hDevice, GX_FLOAT_GAIN, gainRange.dMax);
//设 置 连 续 自 动 增 益
status = GXSetEnum(hDevice, GX_ENUM_GAIN_AUTO,GX_GAIN_AUTO_CONTINUOUS);
```

### 17.2 黑电平

**名词解释**

黑电平：定义图像数据对应的参考电平，调节黑电平不影响信号的放大倍数，仅仅是==对信号进行上下平移==。==向上调节黑电平，图像变亮；向下调节黑电平，图像变暗==。

**相关参数**

X_ENUM_BLACKLEVEL_SELECTOR：       黑电平通道选择，枚举值参GX_BLACKLEVEL_SELECTOR_ENTRY
GX_FLOAT_BLACKLEVEL：                         黑电平值
GX_ENUM_BLACKLEVEL_AUTO：            黑电平自动功能使能，枚举值参考 GX_BLACKLEVEL_AUTO_ENTRY

```c++
//手 动 黑 电 平 调 节------------------------
//使 用 GXGetEnumEntryNums、GXGetEnumDescriptiXon 两 个 接 口
//查 询 当 前 相 机 支 持 的 GX_ENUM_BLACKLEVEL_SELECTOR 类 型
//参 考 接 口 说 明 部 分 ， 此 处 省 略
//假 设 当 前 相 机 支 持 GX_BLACKLEVEL_SELECTOR_ALL
//选 择 黑 电 平 通 道 类 型
status = GXSetEnum(hDevice, GX_ENUM_BLACKLEVEL_SELECTOR,
GX_BLACKLEVEL_SELECTOR_ALL);
//status=GXSetEnum(hDevice,GX_ENUM_BLACKLEVEL_SELECTOR,GX_BLACKLEVEL_SELECTOR_RED);
//status=GXSetEnum(hDevice,GX_ENUM_BLACKLEVEL_SELECTOR,GX_BLACKLEVEL_SELECTOR_GREEN);
//status=GXSetEnum(hDevice,GX_ENUM_BLACKLEVEL_SELECTOR,GX_BLACKLEVEL_SELECTOR_BLUE);
//获 取 黑 电 平 调 节 范 围
GX_FLOAT_RANGE blackLevelRange;
status = GXGetFloatRange(hDevice, GX_FLOAT_BLACKLEVEL, &blackLevelRange);
//设 置 最 小 黑 电 平 值
status = GXSetFloat(hDevice, GX_Float_BLACKLEVEL, blackLevelRange.dMin);
//设 置 最 大 黑 电 平 值
status = GXSetFloat(hDevice, GX_Float_BLACKLEVEL, blackLevelRange.dMax);
//自 动 黑 电 平 设 置--------------------------
//设 置 连 续 自 动 黑 电 平
status = GXSetEnum(hDevice, GX_ENUM_BLACKLEVEL_AUTO, GX_BLACKLEVEL_AUTO_CONTINUOUS);
```

###17.3 白平衡

**名词解释**
➢ 白平衡：在各种不同的色温下，目标物的色彩会产生变化。其中，白色物体变化得最为明显：在室内钨丝灯这样低色温照射下，白色物体看起来会带有橘黄色色调，在这样的光照条件下拍摄出来的景物偏黄；在蔚蓝色天空这样高色温照射下，则会带有蓝色色调，在这种光照条件下拍摄出来的景物偏蓝。==为了尽可能减少外来光线对目标颜色造成影响，在不同的色温条件下都能还原出被拍摄目标本来的色彩，需要进行色彩校正，达到正确的色彩平衡，成为白平衡调整。==
➢ 白平衡控制方式：手动调节方式、自动调节方式。
➢ 自动白平衡关照环境：此值需要用户依据相机所处环境的光源，自行设置，设置完此值后白平衡效果更佳。
➢ 自动白平衡感兴趣区域：自动白平衡采用白平衡“白点”区域（ROI）中的图像数据计算白平衡系数，然后根据计算的系数对图像的各分量进行处理，使 ROI 区域中的红、绿、蓝三分量的值一致。自动白平衡只对彩色传感器有效。

**相关参数**
GX_ENUM_BALANCE_RATIO_SELECTOR：白平衡通道选择，枚举值参考
                                                                             GX_BALANCE_RATIO_SELECTOR_ENTRY
GX_FLOAT_BALANCE_RATIO：                   白平衡系数
GX_ENUM_BALANCE_WHITE_AUTO：       自动白平衡使能，枚举值参考                       GX_BALANCE_WHITE_AUTO_ENTRY
GX_ENUM_AWB_LAMP_HOUSE：自动白平衡光照环境，枚举值参考   GX_AWB_LAMP_HOUSE_ENTRY
GX_INT_AWBROI_OFFSETX：                       自动白平衡感兴趣区域X坐标
GX_INT_AWBROI_OFFSETY：                       自动白平衡感兴趣区域Y坐标
GX_INT_AWBROI_WIDTH：                          自动白平衡感兴趣区域宽度
GX_INT_AWBROI_HEIGHT：                         自动白平衡感兴趣区域高度



```c++
//手 动 白 平 衡 调 节------------------------
//使 用 GXGetEnumEntryNums、GXGetEnumDescription 两 个 接 口
//查 询 当 前 相 机 支 持 的 GX_ENUM_BALANCE_RATIO_SELECTOR 类 型
//参 考 接 口 说 明 部 分 ， 此 处 省 略
//假 设 当 前 相 机 支 持 GX_BALANCE_RATIO_SELECTOR_RED
//选 择 白 平 衡 通 道
status = GXSetEnum(hDevice,GX_ENUM_BALANCE_RATIO_SELECTOR,
GX_BALANCE_RATIO_SELECTOR_RED);
//status=GXSetEnum(hDevice,GX_ENUM_BALANCE_RATIO_SELECTOR,GX_BALANCE_RATIO_SELECTOR_GREEN);
//status=GXSetEnum(hDevice,GX_ENUM_BALANCE_RAT IO_SELECTOR,GX_BALANCE_RATIO_SELECTOR_BLUE);
//获 取 白 平 衡 调 节 范 围
GX_FLOAT_RANGEratioRange;
status = GXGetFloatRange(hDevice, GX_FLOAT_BALANCE_RATIO, &ratioRange);
//设 置 最 小 白 平 衡 系 数
status = GXSetFloat(hDevice, GX_FLOAT_BALANCE_RATIO, ratioRange.dMin);
//设 置 最 大 白 平 衡 系 数
status = GXSetFloat(hDevice, GX_FLOAT_BALANCE_RATIO, ratioRange.dMax);
//设 置 自 动 白 平 衡 感 兴 趣 区 域(代 码 中 参 数 为 举 例 ， 用 户 根 据 自 己 需 要 自 行 修 改 参 数 值 )
status=GXSetInt(hDevice,GX_INT_AWBROI_WIDTH, 100);
status=GXSetInt(hDevice,GX_INT_AWBROI_HEIGHT, 100);
status=GXSetInt(hDevice,GX_INT_AWBROI_OFFSETX, 0);
status=GXSetInt(hDevice,GX_INT_AWBROI_OFFSETY, 0);

//自 动 白 平 衡 设 置--------------------------
//设 置 自 动 白 平 衡 光 照 环 境 ， 比 如 当 前 相 机 所 处 环 境 为 荧 光 灯
status = GXSetEnum(hDevice,GX_ENUM_AWB_LAMP_HOUSE,
GX_AWB_LAMP_HOUSE_FLUORESCENCE);
//设 置 连 续 自 动 白 平 衡
status = GXSetEnum(hDevice,GX_ENUM_BALANCE_WHITE_AUTO,
GX_BALANCE_WHITE_AUTO_CONTINUOUS);
```

如果自动白平衡功能失效，可能是因为自动白平衡感兴趣区域太小，找不到白点造成。



## 18. 传输层控制

### 18.1 PayloadSize

**名词解释**
PayloadSize：==此参数表示相机当前输出的每一帧图像数据大小==(单位：字节)，用户获取图像，分配 buffer大小依据此值。当关闭帧信息的时候，输出图像不附带帧信息，此时 payloadSize 的大小就代表图像大小；当开启帧信息以后，输出图像附带帧信息，此时 payloadSize 的大小等于图像大小加帧信息大小。

**相关参数**

GX_INT_PAYLOAD_SIZE：数据大小

**代码样例**

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
int64_t nValue = 0;
status = GXGetInt(hDevice, GX_INT_PAYLOAD_SIZE, &nValue);
```



### 18.2  IP 配置方式

**相关参数**
GX_BOOL_GEV_CURRENT_IPCONFIGURATION_LLA：LLA 方式配置 IP
GX_BOOL_GEV_CURRENT_IPCONFIGURATION_DHCP：DHCP 方式配置 IP
GX_BOOL_GEV_CURRENT_IPCONFIGURATION_PERSISTENTIP：永久 IP 方式配置 IP

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//本 例 以 永 久 IP 配 置 方 式 说 明 ,其 他 IP 配 置 方 式 类 似
//设 置 为 永 久 IP 配 置 方 式
status = GXSetBool(hDevice, GX_BOOL_GEV_CURRENT_IPCONFIGURATION_PERSISTENTIP, true);
```

### 18.3 预估带宽

### 18.4  设备心跳时间

**名词解释**
设备心跳超时时间：如果在此时间范围内，设备端接收不到来自主控主机的 GVCP 命令包，将会断开与主控主机的连接。

**相关参数**

GX_INT_GEV_HEARTBEAT_TIMEOUT：设备心跳超时时间，单位 ms

**代码样例**

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//读 取 当 前 的 设 备 心 跳 时 间
int64_t nValue = 0;
status = GXGetInt(hDevice, GX_INT_GEV_HEARTBEAT_TIMEOUT, &nValue);
//读 取 设 备 心 跳 时 间 可 设 置 范 围 参 见 GXGetIntRange 接 口 的 使 用 方 法
//设 置 设 备 心 跳 时 间
status = GXSetInt(hDevice, GX_INT_GEV_HEARTBEAT_TIMEOUT, nValue);
```

强烈推荐户使用默认值，除非特殊情况才允许用户根据现场环境修改此值。

###18.5 包长

包长：指 Gige Vision 相机向主机端传输流通道数据的网络包大小，以字节为单位。

GX_INT_GEV_PACKETSIZE：流通道包长

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//读 取 包 长
int64_t nPacketSize = 0;
status = GXGetInt(hDevice, GX_INT_GEV_PACKETSIZE, &nPacketSize);
```

### 18.6 包间隔

包间隔：用于控制 Gige Vision 相机传输图像流数据的带宽。包间隔是在流通道传输的相邻网络数据包之间插入的空闲时钟个数。增加包间隔能够降低相机对网络带宽的占用率，同时也有可能降低了相机的帧率。

GX_INT_GEV_PACKETDELAY：流通道包间隔

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//读 取 包 间 隔
int64_t nPacketDelay = 0;
status = GXGetInt(hDevice, GX_INT_GEV_PACKETDELAY, &nPacketDelay);
```

#### 18.7 链接速度

链接速度：指当前工作的网络环境是千兆网还是百兆网。

GX_INT_GEV_LINK_SPEED：链接速度

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//读 取 当 前 的 连 接 速 度
int64_t nLinkSpeed = 0;
status = GXGetInt(hDevice, GX_INT_GEV_LINK_SPEED, &nLinkSpeed);
```



## 19.带宽控制

控制单台设备的带宽上限,当设备链路带宽限制大于当前设备采集带宽值时，当前设备采集带宽将不发生改变；当设备链路带宽限制小于当前设备采集带宽时，当前设备采集带宽将会下降到设备链路带宽限制以下；当前设备采集带宽可以从相机中读取。

X_INT_DEVICE_LINK_SELECTOR：                                设备链路选择
GX_ENUM_DEVICE_LINK_THROUGHPUT_LIMIT_MODE：设备带宽限制模式
GX_INT_DEVICE_LINK_THROUGHPUT_LIMIT：             设备带宽限制
GX_INT_DEVICE_LINK_CURRENT_THROUGHPUT：   当前设备采集带宽

```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//开 启 带 宽 限 制 模 式
GX_DEVICE_LINK_THROUGHPUT_LIMIT_MODE_ENTRY nValue;
nValue = GX_DEVICE_LINK_THROUGHPUT_LIMIT_MODE_ON;
status = GXSetEnum(hDevice,GX_ENUM_DEVICE_LINK_THROUGHPUT_LIMIT_MODE, nValue);
//查 询 当 前 的 带 宽 值
int64_t nLinkThroughputVal;
status = GXGetInt(hDevice, GX_INT_DEVICE_LINK_CURRENT_THROUGHPUT,
&nLinkThroughputVal);
//设 置 带 宽 限 制 值
int64_t nLinkThroughputLimitVal = 40000000;
status = GXSetInt(hDevice, GX_INT_DEVICE_LINK_THROUGHPUT_LIMIT,
nLinkThroughputLimitVal);
```



## 20. 事件控制

当特定的情形发生时，相机将产生对应的“事件”，并将事件消息发送到 PC 机，告知 PC 有“事件”发生了。比如，在水星千兆网系列相机中，相机会在以下几种情况下产生并传递事件：曝光结束、图像帧数据丢弃、触发信号溢出、图像帧存数据不为空和事件队列溢出。每种事件都有相应的使能位，在默认情况下，相机的所有事件使能都为关闭状态。远端设备事件目前只有水星千兆网系列相机支持。

GX_ENUM_EVENT_SELECTOR：事件源选择,参考 GX_EVENT_SELECTOR_ENTRY
GX_ENUM_EVENT_NOTIFICATION：事件使能,参考 GX_EVENT_NOTIFICATION_ENTRY
GX_INT_EVENT_EXPOSUREEND：曝光结束事件 ID
GX_INT_EVENT_EXPOSUREEND_TIMESTAMP：曝光结束事件时间戳
GX_INT_EVENT_EXPOSUREEND_FRAMEID：曝光结束事件帧 ID
GX_INT_EVENT_BLOCK_DISCARD：数据包丢失事件 ID
GX_INT_EVENT_BLOCK_DISCARD_TIMESTAMP：数据包丢失事件时间戳
GX_INT_EVENT_OVERRUN：事件队列溢出事件 ID
GX_INT_EVENT_OVERRUN_TIMESTAMP：事件队列溢出事件时间戳
GX_INT_EVENT_FRAMESTART_OVERTRIGGER：触发信号被屏蔽事件 ID
GX_INT_EVENT_FRAMESTART_OVERTRIGGER_TIMESTAMP：触发信号被屏蔽事件时间戳
GX_INT_EVENT_BLOCK_NOT_EMPTY：帧存不为空事件 ID
GX_INT_EVENT_BLOCK_NOT_EMPTY_TIMESTAMP：帧存不为空事件时间戳
GX_INT_EVENT_INTERNAL_ERROR：内部错误事件 ID
GX_INT_EVENT_INTERNAL_ERROR_TIMESTAMP：内部错误事件时间戳



## 21. 查找表控制

名词解释
查找表：==查找表为像素值转化的映射表，其与像素值一一对应，用来改变每个像素值输出。==既可用于高位深图像向低位深图像的转化，也可用于同等位深图像单纯的像素值转化。查找表给予用户最大的灵活度，用以实现像素值的线性和非线性变换（如对数修正和指数修正），而无须消耗系统中宝贵的计算资源。
相关参数：
GX_ENUM_LUT_SELECTOR：查找表选择,参考 GX_LUT_SELECTOR_ENTRY
GX_BUFFER_LUT_VALUEALL：查找表内容
GX_BOOL_LUT_ENABLE：查找表使能
GX_INT_LUT_INDEX：查找表索引
GX_INT_LUT_VALUE：查找表值



## 22. 用户配置

这一节描述的是对相机==所有参数配置的控制==，允许用户保存或者加载厂商参数组或者用户参数组。
名词解释
➢ 参数组类型：用户选择一种参数组类型（可能是厂商默认参数组或用户参数组 0），进行保存或者加载操作。
➢ 加载参数组：将用户选定的参数组加载到相机。
➢ 保存参数组：将相机当前的参数保存到用户选定的参数组里面。
➢ 启动参数组：设置设备上电启动的时候使用的参数组。
相关参数
GX_ENUM_USER_SET_SELECTOR：选择要操作的参数组；可能包含厂商默认参数组、用户参数组 0；厂商参数组是只读的，不可修改，即当选择厂商参数组时只能选择加载操作，不能选择保存操作。枚举值   参考 GX_USER_SET_SELECTOR_ENTRY
GX_COMMAND_USER_SET_LOAD：加载所选择的参数组参数到相机
GX_COMMAND_USER_SET_SAVE：将当前相机参数保存到所选择的参数组内
GX_ENUM_USER_SET_DEFAULT：启动参数组,参考 GX_USER_SET_DEFAULT_ENTRY

```c++
//使 用 GXGetEnumEntryNums、GXGetEnumDescription 两 个 接 口
//查 询 当 前 相 机 支 持 的 GX_ENUM_USER_SET_SELECTOR 类 型
//参 考 接 口 说 明 部 分 ， 此 处 省 略
//假 设 当 前 相 机 支 持 厂 商 默 认 参 数 组 、 用 户 参 数 组 0， 共 两 种 参 数 组
//选 择 加 载 厂 商 参 数 组
status = GXSetEnum(hDevice, GX_ENUM_USER_SET_SELECTOR,GX_ENUM_USER_SET_SELECTOR_DEFAULT);
status = GXSendCommand(hDevice, GX_COMMAND_USER_SET_LOAD);
//选 择 加 载 用 户 参 数 组 0
status = GXSetEnum(hDevice, GX_ENUM_USER_SET_SELECTOR,GX_ENUM_USER_SET_SELECTOR_USERSET0);
status = GXSendCommand(hDevice, GX_COMMAND_USER_SET_LOAD);
//设 置 启 动 参 数 组 为 厂 商 参 数 组
emStatus = GXSetEnum(hDevice, GX_ENUM_USER_SET_DEFAULT,GX_ENUM_USER_SET_DEFAULT_DEFAULT);
```

## 23. 设置相机 IP

### 23.1 配置静态IP地址

名词解释
➢ 静态 IP：以静态 IP 方式配置相机 IP。
➢ DHCP：以 DHCP 方式配置相机 IP，即使用 DHCP 服务器分配的 IP。
➢ LLA：以 LLA(Link-Local Address)方式配置相机 IP。
相关参数
GX_IP_CONFIGURE_STATIC_IP：以静态 IP 方式配置相机 IP
GX_IP_CONFIGURE_DHCP：以 DHCP 方式配置相机 IP
GX_IP_CONFIGURE_LLA：以 LLA 方式配置相机 IP
GX_IP_CONFIGURE_DEFAULT：以默认方式配置相机 IP，选用此种方式，相机内部将以上三种配置方式全部使能，但仍会以静态 IP 方式配置相机



```c++
GX_STATUS status = GX_STATUS_SUCCESS;
//示 例 MAC 地 址 ， 实 际 相 机 MAC 地 址 可 用 GXGetDeviceIPInfo 获 得
char szMAC[]= "00-21-49-00-00-00";
char szIpAddress[]= "192.168.10.10";
char szSubnetMask[]= "255.255.255.0";
char szDefaultGateway[] = "192.168.10.2";
char szUserID[]= "Daheng Imaging";
GX_IP_CONFIGURE_MODE emIpConfigureMode = IP_CONFIGURE_STATIC_IP;
//本 例 以 永 久 IP 配 置 方 式 说 明 ,其 他 IP 配 置 方 式 类 似
//设 置 为 永 久 IP 配 置 方 式
status = GXGigEIpConfiguration(szMAC, emIpConfigureMode,szIpAddress,szSubnetMask, szDefaultGateway, szUserID);
```

调用此接口前，必须先进行枚举操作，并且执行此操作时相机不能是打开状态。
➢ 当选用 GX_IP_CONFIGURE_STATIC_IP 和 GX_IP_CONFIGURE_DEFAULT 参数配置 IP 时，传入接口的 IP 地址、子网掩码、默认网关等参数指针不允许为 NULL。
➢ 当选用 GX_IP_CONFIGURE_LLA 和 GX_IP_CONFIGURE_DHCP 参数配置 IP 时，传入接口的 IP地址、子网掩码、默认网关等参数指针可以为 NULL。
➢ 用户自定义名称（UserID）允许的最大长度是 16 个字符；使用任何一种方式配置相机 IP，传入接口的用户自定义名称（UserID）参数指针均可以是 NULL。



## 

















